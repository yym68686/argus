<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Argus Chat (App Server JSON-RPC v2)</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0b0f19;
        --panel: #101826;
        --panel-2: #0d1522;
        --text: #e6edf7;
        --muted: #9fb2cc;
        --border: #24324a;
        --accent: #5b8cff;
        --danger: #ff5b6e;
        --ok: #5bff9f;
        --user: #1a2a44;
        --assistant: #121b2a;
        --code: #0a0f18;
      }

      @media (prefers-color-scheme: light) {
        :root {
          --bg: #f7f9fd;
          --panel: #ffffff;
          --panel-2: #f3f6fb;
          --text: #0c1320;
          --muted: #5b6b85;
          --border: #dde6f3;
          --accent: #2f5cff;
          --danger: #d62f43;
          --ok: #0aa85c;
          --user: #e9f0ff;
          --assistant: #f6f8fc;
          --code: #eef3ff;
        }
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
        background: var(--bg);
        color: var(--text);
      }

      .app {
        max-width: 980px;
        margin: 0 auto;
        padding: 20px;
        display: grid;
        gap: 12px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 14px;
        overflow: hidden;
      }

      .toolbar {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        padding: 14px;
        background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      }

      .toolbar .left {
        display: grid;
        gap: 10px;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      label {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="text"],
      select,
      textarea {
        width: 100%;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px 12px;
        color: var(--text);
        outline: none;
      }

      input[type="text"]:focus,
      select:focus,
      textarea:focus {
        border-color: color-mix(in oklab, var(--accent) 60%, var(--border));
        box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent) 22%, transparent);
      }

      select {
        width: auto;
      }

      .meta {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .pill {
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: color-mix(in oklab, var(--panel) 80%, transparent);
      }

      .pill.ok {
        border-color: color-mix(in oklab, var(--ok) 35%, var(--border));
        color: color-mix(in oklab, var(--ok) 80%, var(--text));
      }

      .pill.bad {
        border-color: color-mix(in oklab, var(--danger) 35%, var(--border));
        color: color-mix(in oklab, var(--danger) 80%, var(--text));
      }

      button {
        border: 1px solid var(--border);
        background: color-mix(in oklab, var(--panel) 80%, var(--panel-2));
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        cursor: pointer;
      }

      button:hover {
        border-color: color-mix(in oklab, var(--accent) 35%, var(--border));
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      button.primary {
        background: color-mix(in oklab, var(--accent) 20%, var(--panel));
        border-color: color-mix(in oklab, var(--accent) 50%, var(--border));
      }

      .chat {
        height: min(68vh, 720px);
        overflow: auto;
        padding: 14px;
        display: grid;
        gap: 10px;
        background: var(--panel);
      }

      .msg {
        display: grid;
        gap: 6px;
        padding: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
      }

      .msg.user {
        background: var(--user);
        justify-self: end;
        max-width: 92%;
      }

      .msg.assistant {
        background: var(--assistant);
        justify-self: start;
        max-width: 92%;
      }

      .msg .role {
        font-weight: 600;
        font-size: 12px;
        color: var(--muted);
      }

      .msg pre {
        margin: 0;
        padding: 10px;
        background: var(--code);
        border: 1px solid color-mix(in oklab, var(--border) 70%, transparent);
        border-radius: 12px;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 13px;
        line-height: 1.45;
      }

      .composer {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        padding: 14px;
        border-top: 1px solid var(--border);
        background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      }

      textarea {
        resize: none;
        height: 44px;
        max-height: 180px;
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
        padding: 0 14px 14px 14px;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="panel">
        <div class="toolbar">
          <div class="left">
            <div class="row">
              <div style="flex: 1; min-width: 260px">
                <label for="wsUrl">WebSocket URL</label>
                <input id="wsUrl" type="text" spellcheck="false" />
              </div>
              <div>
                <label for="cwd">CWD</label>
                <input
                  id="cwd"
                  type="text"
                  value="/workspace"
                  spellcheck="false"
                  style="width: 220px"
                />
              </div>
              <div>
                <label for="approvalPolicy">Approval</label>
                <select id="approvalPolicy">
                  <option value="never" selected>never</option>
                  <option value="on-request">on-request</option>
                  <option value="on-failure">on-failure</option>
                  <option value="untrusted">untrusted</option>
                </select>
              </div>
              <div>
                <label for="sandboxMode">Sandbox</label>
                <select id="sandboxMode">
                  <option value="workspace-write" selected>workspace-write</option>
                  <option value="read-only">read-only</option>
                  <option value="danger-full-access">danger-full-access</option>
                </select>
              </div>
            </div>
            <div class="meta">
              <span id="connPill" class="pill bad">disconnected</span>
              <span class="pill">session: <span id="sessionId">-</span></span>
              <span class="pill">thread: <span id="threadId">-</span></span>
              <span class="pill">turn: <span id="turnId">-</span></span>
            </div>
            <div class="meta">
              <label style="display: inline-flex; align-items: center; gap: 8px">
                <input id="resumeLast" type="checkbox" />
                Resume last thread
              </label>
              <span class="pill">saved: <span id="savedThreadId">-</span></span>
              <button id="clearSavedBtn" type="button">Clear</button>
            </div>
          </div>
          <div class="row" style="justify-content: flex-end; align-items: flex-start">
            <button id="connectBtn" class="primary">Connect</button>
            <button id="newThreadBtn" disabled>New thread</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
          </div>
        </div>

        <div id="chat" class="chat"></div>

        <div class="composer">
          <textarea
            id="prompt"
            placeholder="Type a prompt…"
            autocomplete="off"
            spellcheck="false"
          ></textarea>
          <button id="sendBtn" class="primary" disabled>Send</button>
        </div>
        <div class="hint">
          Enter to send, Shift+Enter for newline. The UI enforces sequential turns
          (waits for <code>turn/completed</code> before allowing the next send).
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id)

      const wsUrlInput = $("wsUrl")
      const cwdInput = $("cwd")
      const approvalPolicySelect = $("approvalPolicy")
      const sandboxModeSelect = $("sandboxMode")
      const connPill = $("connPill")
      const sessionIdEl = $("sessionId")
      const threadIdEl = $("threadId")
      const turnIdEl = $("turnId")
      const resumeLastEl = $("resumeLast")
      const savedThreadIdEl = $("savedThreadId")
      const clearSavedBtn = $("clearSavedBtn")
      const chatEl = $("chat")
      const promptEl = $("prompt")
      const sendBtn = $("sendBtn")
      const connectBtn = $("connectBtn")
      const newThreadBtn = $("newThreadBtn")
      const disconnectBtn = $("disconnectBtn")

      const STORAGE = {
        lastThreadId: "argus_webchat_last_thread_id",
        resumeLast: "argus_webchat_resume_last",
      }

      const storage = (() => {
        try {
          const k = "__argus_webchat_test__"
          localStorage.setItem(k, "1")
          localStorage.removeItem(k)
          return {
            ok: true,
            get: (key) => localStorage.getItem(key),
            set: (key, value) => localStorage.setItem(key, value),
            remove: (key) => localStorage.removeItem(key),
          }
        } catch {
          return {
            ok: false,
            get: (_key) => null,
            set: (_key, _value) => {},
            remove: (_key) => {},
          }
        }
      })()

      const state = {
        ws: null,
        nextId: 1,
        pending: new Map(),
        initialized: false,
        sessionId: null,
        threadId: null,
        activeTurnId: null,
        activeAssistantPre: null,
        turnInProgress: false,
      }

      function defaultWsUrl() {
        if (location.protocol === "http:" || location.protocol === "https:") {
          const wsProto = location.protocol === "https:" ? "wss:" : "ws:"
          return `${wsProto}//${location.host}/ws`
        }
        return "ws://127.0.0.1:8080/ws"
      }

      wsUrlInput.value = defaultWsUrl()

      function getSavedThreadId() {
        const id = storage.get(STORAGE.lastThreadId)
        return id && id.trim() ? id.trim() : null
      }

      function setSavedThreadId(id) {
        if (!id) return
        storage.set(STORAGE.lastThreadId, id)
        savedThreadIdEl.textContent = id
      }

      function clearSavedThreadId() {
        storage.remove(STORAGE.lastThreadId)
        savedThreadIdEl.textContent = "-"
      }

      function loadResumePref() {
        const raw = storage.get(STORAGE.resumeLast)
        if (raw === null) return true
        return raw === "1"
      }

      function saveResumePref(v) {
        storage.set(STORAGE.resumeLast, v ? "1" : "0")
      }

      resumeLastEl.checked = loadResumePref()
      savedThreadIdEl.textContent = getSavedThreadId() ?? "-"
      if (!storage.ok) {
        addMessage(
          "assistant",
          "Note: localStorage is unavailable in this browser context, so thread resume will not persist across reloads."
        )
      }

      function setConnStatus(connected, message) {
        connPill.textContent = message
        connPill.classList.toggle("ok", connected)
        connPill.classList.toggle("bad", !connected)
      }

      function scrollToBottom() {
        chatEl.scrollTop = chatEl.scrollHeight
      }

      function addMessage(role, text) {
        const wrap = document.createElement("div")
        wrap.className = `msg ${role}`

        const roleEl = document.createElement("div")
        roleEl.className = "role"
        roleEl.textContent = role

        const pre = document.createElement("pre")
        pre.textContent = text ?? ""

        wrap.appendChild(roleEl)
        wrap.appendChild(pre)
        chatEl.appendChild(wrap)
        scrollToBottom()
        return pre
      }

      function setUiState() {
        const connected = !!state.ws && state.ws.readyState === WebSocket.OPEN
        const ready = connected && !!state.threadId && !state.turnInProgress
        sendBtn.disabled = !ready
        promptEl.disabled = !ready
        newThreadBtn.disabled = !connected || state.turnInProgress
        disconnectBtn.disabled = !connected
      }

      function sendRaw(obj) {
        state.ws.send(JSON.stringify(obj))
      }

      function rpc(method, params) {
        const id = state.nextId++
        const req = { method, id }
        if (params !== undefined) req.params = params
        sendRaw(req)
        return new Promise((resolve, reject) => {
          state.pending.set(id, { resolve, reject })
          setTimeout(() => {
            if (state.pending.has(id)) {
              state.pending.delete(id)
              reject(new Error(`Timeout waiting for response to ${method} (${id})`))
            }
          }, 120000)
        })
      }

      function handleServerRequest(msg) {
        const method = msg.method
        const id = msg.id

        if (method === "item/commandExecution/requestApproval") {
          sendRaw({ id, result: { decision: "decline" } })
          return
        }
        if (method === "item/fileChange/requestApproval") {
          sendRaw({ id, result: { decision: "decline" } })
          return
        }

        sendRaw({
          id,
          error: { code: -32601, message: `Unsupported server request: ${method}` },
        })
      }

      function handleNotification(msg) {
        const method = msg.method
        const params = msg.params || {}

        if (method === "argus/session") {
          if (params.id) {
            state.sessionId = String(params.id)
            sessionIdEl.textContent = state.sessionId
          }
          return
        }

        if (method === "turn/started") {
          const turn = params.turn || {}
          if (params.threadId !== state.threadId) return
          if (state.turnInProgress && !state.activeTurnId && turn.id) {
            state.activeTurnId = turn.id
            turnIdEl.textContent = state.activeTurnId
          }
          return
        }

        if (method === "item/agentMessage/delta") {
          if (params.threadId !== state.threadId) return
          if (state.turnInProgress && !state.activeTurnId && params.turnId) {
            state.activeTurnId = params.turnId
            turnIdEl.textContent = state.activeTurnId
          }
          if (state.activeTurnId && params.turnId !== state.activeTurnId) return
          if (!state.activeAssistantPre) return
          state.activeAssistantPre.textContent += params.delta || ""
          scrollToBottom()
          return
        }

        if (method === "item/completed") {
          const item = params.item || {}
          if (params.threadId !== state.threadId) return
          if (state.turnInProgress && !state.activeTurnId && params.turnId) {
            state.activeTurnId = params.turnId
            turnIdEl.textContent = state.activeTurnId
          }
          if (state.activeTurnId && params.turnId !== state.activeTurnId) return
          if (item.type === "agentMessage" && state.activeAssistantPre) {
            state.activeAssistantPre.textContent = item.text || ""
            scrollToBottom()
          }
          return
        }

        if (method === "turn/completed") {
          const turn = params.turn || {}
          if (!state.turnInProgress) return
          if (params.threadId !== state.threadId) return
          if (state.activeTurnId && turn.id !== state.activeTurnId) return
          if (turn.id && !state.activeTurnId) {
            state.activeTurnId = turn.id
            turnIdEl.textContent = state.activeTurnId
          }
          if (turn.id) {
            state.turnInProgress = false
            state.activeTurnId = null
            state.activeAssistantPre = null
            turnIdEl.textContent = "-"
            setUiState()
          }
          return
        }
      }

      async function initializeConnection() {
        if (state.initialized) return
        await rpc("initialize", {
          clientInfo: { name: "web_chat", title: "Web Chat", version: "0.0.1" },
        })
        sendRaw({ method: "initialized" })
        state.initialized = true
      }

      async function startThread() {
        state.threadId = null
        state.activeTurnId = null
        state.turnInProgress = false
        threadIdEl.textContent = "-"
        turnIdEl.textContent = "-"
        chatEl.textContent = ""
        setUiState()

        const threadStart = await rpc("thread/start", {
          cwd: cwdInput.value,
          approvalPolicy: approvalPolicySelect.value,
          sandbox: sandboxModeSelect.value,
        })

        state.threadId = threadStart.thread.id
        threadIdEl.textContent = state.threadId
        setSavedThreadId(state.threadId)
        setUiState()
      }

      async function resumeThread(threadId) {
        state.threadId = null
        state.activeTurnId = null
        state.turnInProgress = false
        threadIdEl.textContent = "-"
        turnIdEl.textContent = "-"
        setUiState()

        const resumed = await rpc("thread/resume", { threadId })
        state.threadId = resumed.thread.id
        threadIdEl.textContent = state.threadId
        setSavedThreadId(state.threadId)
        setUiState()
      }

      async function connect() {
        if (state.ws && state.ws.readyState === WebSocket.OPEN) return
        setConnStatus(false, "connecting…")
        setUiState()

        let ws
        try {
          ws = new WebSocket(wsUrlInput.value)
        } catch (err) {
          setConnStatus(false, "error")
          addMessage("assistant", `WebSocket URL error: ${err?.message || String(err)}`)
          return
        }
        state.ws = ws
        state.pending.clear()

        ws.addEventListener("open", async () => {
          setConnStatus(true, "connected")
          connectBtn.disabled = true
          try {
            state.initialized = false
            await initializeConnection()
            const saved = getSavedThreadId()
            const wantResume = resumeLastEl.checked && !!saved
            if (wantResume) {
              try {
                await resumeThread(saved)
              } catch {
                await startThread()
              }
            } else {
              await startThread()
            }
          } catch (err) {
            addMessage("assistant", `Error: ${err?.message || String(err)}`)
          } finally {
            connectBtn.disabled = false
            setUiState()
          }
        })

        ws.addEventListener("close", (ev) => {
          const code = ev?.code
          const reason = ev?.reason
          const msg = code ? `disconnected (${code}${reason ? `: ${reason}` : ""})` : "disconnected"
          setConnStatus(false, msg)
          state.initialized = false
          state.sessionId = null
          state.threadId = null
          state.activeTurnId = null
          state.turnInProgress = false
          sessionIdEl.textContent = "-"
          threadIdEl.textContent = "-"
          turnIdEl.textContent = "-"
          connectBtn.disabled = false
          setUiState()
        })

        ws.addEventListener("error", () => {
          setConnStatus(false, "error")
        })

        ws.addEventListener("message", (ev) => {
          let msg
          try {
            msg = JSON.parse(ev.data)
          } catch {
            return
          }

          if (msg.id !== undefined && msg.method) {
            handleServerRequest(msg)
            return
          }

          if (msg.id !== undefined) {
            const pending = state.pending.get(msg.id)
            if (!pending) return
            state.pending.delete(msg.id)
            if (msg.error) pending.reject(new Error(msg.error.message || "RPC error"))
            else pending.resolve(msg.result)
            return
          }

          if (msg.method) {
            handleNotification(msg)
          }
        })
      }

      function disconnect() {
        if (!state.ws) return
        try {
          state.ws.close()
        } catch {}
      }

      async function sendTurn() {
        const text = promptEl.value.trim()
        if (!text || !state.threadId || state.turnInProgress) return

        addMessage("user", text)
        const assistantPre = addMessage("assistant", "")
        promptEl.value = ""
        promptEl.style.height = "44px"

        state.turnInProgress = true
        state.activeAssistantPre = assistantPre
        setUiState()

        try {
          const turnStart = await rpc("turn/start", {
            threadId: state.threadId,
            input: [{ type: "text", text }],
            cwd: cwdInput.value,
            approvalPolicy: approvalPolicySelect.value,
            sandboxPolicy: { type: "externalSandbox", networkAccess: "enabled" },
          })
          state.activeTurnId = turnStart.turn.id
          turnIdEl.textContent = state.activeTurnId
        } catch (err) {
          assistantPre.textContent = `Error: ${err?.message || String(err)}`
          state.turnInProgress = false
          state.activeTurnId = null
          state.activeAssistantPre = null
          turnIdEl.textContent = "-"
          setUiState()
        }
      }

      function autosizeTextarea() {
        promptEl.style.height = "0px"
        const next = Math.min(promptEl.scrollHeight, 180)
        promptEl.style.height = `${Math.max(next, 44)}px`
      }

      connectBtn.addEventListener("click", connect)
      disconnectBtn.addEventListener("click", disconnect)
      resumeLastEl.addEventListener("change", () => saveResumePref(resumeLastEl.checked))
      clearSavedBtn.addEventListener("click", () => clearSavedThreadId())
      newThreadBtn.addEventListener("click", async () => {
        if (!state.ws || state.ws.readyState !== WebSocket.OPEN) return
        try {
          await startThread()
        } catch (err) {
          addMessage("assistant", `Error: ${err?.message || String(err)}`)
        }
      })
      sendBtn.addEventListener("click", sendTurn)
      promptEl.addEventListener("input", autosizeTextarea)
      promptEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault()
          sendTurn()
        }
      })

      setConnStatus(false, "disconnected")
      setUiState()
    </script>
  </body>
</html>
